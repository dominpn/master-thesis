
\chapter{Model systemu rekomendacyjnego chroniącego prywatność}

W rozdziale zaproponowanie rozwiązania zwiększającego bezpieczeństwo oraz zachowanie prywatnych danych użytkownika. W tym celu wykorzystano \textit{Federated learning} omówiony w rozdziale \ref{section:federatedLearning} wraz z dodatkowymi zabezpieczeniami mającymi na celu zniwelować przedstawione problemy związane z tym rozwiązaniem. Także przedstawiono jak mógłby wyglądać proces przygotowania takiej metody dla nowo-powstałego systemu jak i dla już zaimplementowanego systemu z wykorzystaniem dostępnych bibliotek i technologii.

\section{Projekt rozwiązania}

W proponowanym rozwiązaniu (przedstawionym na rys. \ref{fig:schemat} wyróżniono trzech aktorów. Pierwszy z nich, zwykły użytkownik uczestniczy w normalnym przebiegu zaproponowanym w rozwiązaniu \textit{Federated learning}. Użytkownik na podstawie swoich danych poprawia otrzymany przez serwer model, następnie bez ujawniania swoich danych przekazuje dalej wyłącznie poprawiony przez siebie model.

Jednym z potencjalnych problemów może być założenie, że użytkownicy będą uczciwie uczestniczyć w całym omawianym procesie. Oznacza, to że użytkownik może zmniejszyć skuteczność modelu rekomendacji poprzez umieszczenie w nich niepoprawnych danych (niezgodnych z rzeczywistością). W przypadku pojedynczego użytkownika, który próbuje zakłócić pracę systemu istnieje mechanizm uśredniający otrzymane wyniki od wszystkich użytkowników. Jednak w przypadku zorganizowanego ataku z wielu kont wyłącznie normalizacja może nie być wystarczająca. W celu poradzenia sobie z tym problemem wprowadzono drugi typ aktora - użytkownik niezaufany, który ma możliwość wyłącznie otrzymania modelu od serwera głównego. Jest on wyłączony z usprawnienia udostępnianego modelu (nie wysyła on swoich rezultatów uczenia). Tego typu użytkownik po określonym czasie użytkowania systemu, ilości wystawionych ocen lub po odpowiednim procesie weryfikacyjnym może zostać przemianowany na zwykłego użytkownika uczestniczącego w procesie usprawniania wspólnego modelu.

Kolejnym problemem może być koszt nauki na systemach mobilnych. Niektórzy użytkownicy mogą posiadać słabszy sprzęt (zasoby sprzętowe czy bateria), który może uniemożliwić ponowne uczenie otrzymanego modelu na urządzeniu. W przypadku wolnego łącza lub jego braku, problemem może być pobieranie lub odesłanie modelu do głównego serwera. W tym celu użytkownik z ograniczonymi zasobami zostałby zmuszony do przesłania swoich zaszyfrowanych danych do serwera, tam wykorzystując właściwości szyfrowania homomorficznego model zostałby zaktualizowany, a rekomendacje przesłane do użytkownika.

\begin{figure}[h]
    \includegraphics[scale=0.75]{schemat_protokolu.png}
    \caption{Schemat bezpiecznego protokołu.}
    \label{fig:schemat}
\end{figure}

\section{Fazy budowania systemu rekomendacyjnego}

Podczas implementacji systemu rekomendacyjnego wykorzystano typowy przepływ (przedstawiony na rysunku \ref{fig:rs_pipeline}) używany do tworzenia tego typu serwisów, który składa się z następujących pięciu faz \cite{rs_in_real}:
\begin{itemize}
    \item wstępne przetwarzanie - na ten etap składają się czynności związane z transformacją danych do macierzy użytkownik-produkt oraz normalizacja w celu spłaszczenia wartości odstających (użytkownicy, którzy są nad wyraz pozytywni oraz negatywni w stosunku do dawania ocen),
    \item trenowanie - proces budowania modelu,
    \item optymalizacja hiper parametrów - wielokrotne trenowanie w celu dostrojenia parametrów w taki sposób, aby uzyskać jak najlepsze wyniki,
    \item przetwarzanie końcowe - sortowanie danych w celu uzyskania N najlepszych rekomendacji dla użytkownika, filtrowanie oraz wykluczenie wcześniej zakupionych lub negatywnie ocenionych przedmiotów,
    \item ewaluacja - testowanie stworzonego modelu poprzez ukrywanie/maskowanie ocen, a następnie użycie miar do ewaluacji (szczegółowo opisane w podrozdziale \ref{metryki}).
\end{itemize}{}

\begin{figure}[h]
    \includegraphics[scale=0.85]{rs_pipeline.png}
    \caption{Fazy przepływu podczas tworzenia systemu rekomendacyjnego.}
    \label{fig:rs_pipeline}
\end{figure}

\section{Dane testowe}

Do testów wykorzystano zbiór MovieLens (dostępny na stronie \url{https://grouplens.org/datasets/movielens}) zebrany przez laboratorium badawcze \textit{GroupLens} działające na Wydziale Informatyki i Inżynierii Uniwersytetu w Minnesota. Dane zawierają zanonimizowane informacje o filmach (nazwa, tagi) oraz użytkownikach. Oceny filmów zaprezentowane są w skali pięciostopniowej z przyrostem o pół oceny (od 0.5 do 5.0). Fragment danych został przedstawiony na rys. \ref{fig:movie_lens} w formie macierzy film-użytkownik (kolumny zawierają identyfikator filmu, natomiast wiersze identyfikator użytkownika).

\begin{figure}[h]
    \includegraphics[scale=0.6]{movie_lens.png}
    \caption{Fazy przepływu podczas tworzenia systemu rekomendacyjnego.}
    \label{fig:movie_lens}
\end{figure}

\section{Przegląd dostępnych technologii}

Istnieje wiele dostępnych bibliotek czy frameworków umożliwiających na implementacje rozwiązań typu \textit{Federated learning}. Większość z nich umożliwia na napisanie kodu w języku Python. Jednymi z bardziej popularnych oraz dobrze udokumentowanych są następujące technologie:

\begin{itemize}
    \item PySyft - narzędzie opracowane przez grupę OpenMinded. PySyft rozszerza popularne biblioteki takie jak: PyTorch, Tensorflow oraz Keras o możliwość zdalnego wykonywania, szyfrowania homomorficznego czy obliczenia z wykorzystaniem wielu użytkowników,
    \item Tensorflow Federated - biblioteka wykorzystywana do uczenia maszynowego i innych obliczeń na danych niescentralizowanych oparta o otwarty kod źródłowy. Stworzona w celu badań oraz eksperymentowania z koncepcją \textit{Federated learning}.
\end{itemize}

\section{Fragmenty implementacji}

Na listingu \ref{lst:initPyTorch} pokazano jak inicjowani są klienci uczestniczący w procesie uczenia oraz rozdzielenie danych na poszczególnych klientów z wykorzystaniem bibilioteki \textit{PySyft}. Klienci tworzeni są poprzez wywołanie konstruktora \textit{VirtualWorker}, natomiast za pomocą metody \textit{federate} rozdzielane są dane dla klientów 1 oraz 2, które trafiają do dostawcy (\textit{FederatedDataLoader}).

\begin{lstlisting}[language=Python, caption={Inicjalizacja klientów oraz podział danych}, label={lst:initPyTorch}, captionpos=b]
hook = sy.TorchHook(torch)
client1 = sy.VirtualWorker(hook, id="client1")
client2 = sy.VirtualWorker(hook, id="client2")

train_set = UserItemRatingDataset(X_train, y_train)
test_set = UserItemRatingDataset(X_test, y_test)

federated_train_loader = sy.FederatedDataLoader(
    train_set.federate((client1, client2)), 
    batch_size=64, shuffle=True)

test_loader = torch.utils.data.DataLoader(
    test_set, batch_size=64, shuffle=True)
\end{lstlisting}

